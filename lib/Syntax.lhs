\subsection{Syntax of BSML}
\label{sec:BSML_syntax}
\begin{code}
{-# LANGUAGE LambdaCase #-}
module Syntax where

import Test.QuickCheck

\end{code}
This module describes the syntactical elements of BSML.
We define formulas, some syntactical operations and provide generators for random formulas.

The formulas of BSML are defined as follows:
\begin{code}
type Proposition = Int

-- Formulas of BSML.
data Form
  = Bot
  | NE
  | Prop Proposition
  | Neg Form
  | And Form Form
  | Or  Form Form
  | Dia Form
  deriving (Eq,Show)
\end{code}
Readers familiar with Modal Logic (see e.g.\cite{BdRV}) should recognize this as
the basic modal language, extended with \verb|NE|, the nonemptiness atom.
As we will see when defining the semantics, this atom is used to exclude the
assertion of logical statements due to empty information-configurations (i.e. states/teams).

Further, we define some abbreviations for formulas, following \cite{Aloni2024}:
\begin{code}
-- Define box as the dual of diamond.
box :: Form -> Form
box = Neg . Dia . Neg

-- Define the strong contradiction (which is never assertable).
botbot :: Form
botbot = And Bot NE

-- NE functions as a weak tautology (assertable in non-empty states).
top :: Form
top = NE

-- Define the strong tautology (which is always assertable).
toptop :: Form
toptop = Neg Bot
\end{code}

As in \cite{Aloni2024}, we can use these notions of contradiction and tautology
to interpret finite disjunctions and conjunctions:

\begin{code}
bigor :: [Form] -> Form
bigor [] = Bot
bigor fs = foldr1 Or fs

bigand :: [Form] -> Form
bigand [] = toptop
bigand fs = foldr1 And fs
\end{code}

Note that we could have (semantically equivalently) defined e.g.
\begin{showCode}
bigor :: [Form] -> Form
bigor = foldr Or Bot
\end{showCode}
but this would have had the undesired side-effect of including Bot in \emph{every}
disjunction, including non-empty ones.

\subsubsection{Arbitrary Form}
In order to verify some properties of BSML, we would like to be able to generate
random formulas. We will use QuickCheck's ecosystem for this purpose, so we only
need to define an instance of \verb|Arbitrary| for \verb|Form|.

First, we fix a number of propositions, which we will also use when generating
random valuations for models.
This guarantees that random models and formulas have a more meaningful interaction,
in the sense that the formulas will actually refer to the propositions that occur in the model.
\begin{code}
-- We use proposition in the range (1, numProps).
numProps :: Int
numProps = 32
\end{code}
One might wonder why we do not use the size parameter of a generator to determine the range of propositions.
We intentionally avoided this, because it would introduce a bias in the occurence of
Propositions, where e.g. more nested subformulas will not contain high propositions.

Now we can define the \verb|Arbitrary Form|-instance using a standard sized generator,
where formulas generated with size $0$ are random atoms and larger formulas are
generated by applying a random constructor to random smaller formulas.
\begin{code}
-- Generate a random atom.
randomAtom :: Gen Form
randomAtom = oneof [Prop <$> choose (1, numProps), pure NE, pure Bot]

instance Arbitrary Form where
  arbitrary = sized $ \case
    0 -> randomAtom
    _ ->  oneof [
        randomAtom,
        Neg <$> f,
        And <$> f <*> f,
        Or  <$> f <*> f,
        Dia <$> f
      ]
    where f = scale (`div` 2) arbitrary
\end{code}
The choice to scale the size of the generator by dividing it by 2 is completely arbitrary,
but seems to work well in practice and is used in similar projects, see e.g. \cite{SMCDEL}.