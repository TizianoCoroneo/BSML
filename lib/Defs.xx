
\begin{code}

data TeamPointedModel = TPM KrM Team
  deriving (Show)

data WorldPointedModel = WPM KrM World
  deriving (Show)
\end{code}

\begin{code}

teamRel :: KrM -> Team -> Set World
teamRel m s = Set.unions $ Set.map (rel' m) s

\end{code}

\begin{code}

instance Supportable KrM Team Form where
  (_,s) |= Bot     = null s
  (_,s) |= NE      = not (null s)
  (m,s) |= Prop n  = all (elem n) $ Set.map (val' m) s
  (m,s) |= Neg f   = (m,s) =| f
  (m,s) |= And f g = (m,s) |= f && (m,s) |= g
  (m,s) |= Or f g  = any (\(t,u) -> t <> u == s && (m,t) |= f && (m,u) |= g) $ teamParts s
  (m,s) |= Dia f   = all (any (\t -> not (null t) && (m,t) |= f) . Set.powerSet . rel' m) s

instance Antisupportable KrM Team Form where
  _     =| Bot     = True
  (_,s) =| NE      = null s
  (m,s) =| Prop n  = not . any (elem n) $ Set.map (val' m) s
  (m,s) =| Neg f   = (m,s) |= f
  (m,s) =| And f g = any (\(t,u) -> t <> u == s && (m,t) =| f && (m,u) =| g) $ teamParts s
  (m,s) =| Or f g  = (m,s) =| f && (m,s) =| g
  (m,s) =| Dia f   = all (\w -> (m, rel' m w) =| f) s

\end{code}

One may also easily extend the above semantics to lists of formulae, as shown below.

\begin{code}
instance Supportable KrM Team [Form] where
  support = (all .) . support

instance Antisupportable KrM Team [Form] where
  antisupport = (all .) . antisupport

\end{code}

We write first a function that describes $\Box$ formulae - much like in several standard modal logics, $\Box \varphi \equiv \neg \lozenge \neg \varphi$
for any formula $\varphi$.

We note that $\bot$ as defined here is only false on all non-empty teams. It is therefore referred to in \cite{Aloni2024} as the
\textit{weak contradiction}. The strong contradiction (referred to in \cite{Aloni2024} as $\botbot$) is the formula $\bot \land \texttt{NE}$, which
is called \texttt{botbot} below. Dually, the formula \texttt{NE} serves as the \textit{weak tautology} here; it is true
on all non-empty teams. The formula $\toptop \coloneqq \neg \bot$ is true everywhere, and is therefore called the \textit{strong tautology}.

The following code block implements the Arbitrary typeclass for models (KrM), pointed models (TeamPointedModel or WorldPointedModel), and formulas (both BML formulas in MForm, and BSML formulas in Form).

We start by defining some parameters that will be used in the generators.



The instance for a Kripke model KrM first generates an arbitrary set of worlds ws, from 0 to an arbitrary k;
then, it generates an arbitrary Map world to subset of all worlds to represent the model relation.
Finally, it generates the valuation Map by picking an arbitrary list of propositions from the range (0, numProps).

\begin{code}
subsetOf :: Ord a => [a] -> Gen (Set a)
subsetOf = (Set.fromList <$>) . sublistOf

instance Arbitrary KrM where
  arbitrary = sized (\n -> do
    k <- choose (0, n)
    let ws = Set.fromList [0..k]
    r <- Map.fromList . zip [0..k] <$> vectorOf (k+1) (subsetOf [0..k])
    v <- Map.fromList . zip [0..k] <$> vectorOf (k+1) (subsetOf [1..numProps])
    return $ KrM ws r v)
\end{code}

In the instances for pointed models, we want to make sure that the team or world that we're focusing on is actually part of the model.
We do that by picking a team or a world respectively as an arbitrary subset or element of the model's worlds.

\begin{code}
instance Arbitrary TeamPointedModel where
  arbitrary = do
    m <- arbitrary
    s <- subsetOf $ Set.toList $ worlds m
    return $ TPM m s

instance Arbitrary WorldPointedModel where
  arbitrary = do
    m <- arbitrary
    w <- elements (Set.toList $ worlds m)
    return $ WPM m w
\end{code}

For the Arbitrary instance of the formulas, we check the size parameter:
if it is 0, we choose an atom to terminate the recursion.
Otherwise, we pick one of the other available operators that we can use in an arbitrary formula.

\begin{code}
randomMProp :: Gen MForm
randomMProp = MProp <$> choose (1, numProps)

instance Arbitrary MForm where
  arbitrary = sized $ \case
    0 -> randomMProp
    _ -> oneof [
      randomMProp,
      MNeg <$> f,
      MAnd <$> f <*> f,
      MOr  <$> f <*> f,
      MDia <$> f]
    where f = scale (`div` 2) arbitrary
\end{code}
Some example models.

\begin{code}
-- Aloni2024 - Figure 3.
w0, wp, wq, wpq :: Int
wp  = 0
wq  = 1
wpq = 2
w0  = 3

u3 :: Set World
u3 = Set.fromList [0..3]

r3a, r3b, r3c :: Map World (Set World)
r3a = Map.fromSet (const Set.empty) u3

r3b = Map.fromSet r u3 where
  r 2 = Set.fromList [wp, wpq]
  r 3 = Set.singleton wq
  r _ = Set.empty

r3c = Map.fromSet r u3 where
  r 2 = Set.fromList [wp, wq]
  r _ = Set.empty

v3 :: Map World (Set Proposition)
v3 = Map.fromList [
    (0, Set.singleton 1),
    (1, Set.singleton 2),
    (2, Set.fromList [1,2]),
    (3, Set.empty)
  ]

m3a, m3b, m3c :: KrM
m3a = KrM u3 r3a v3
m3b = KrM u3 r3b v3
m3c = KrM u3 r3c v3

s3a1, s3a2, s3b, s3c :: Team
s3a1 = Set.singleton wq
s3a2 = Set.fromList [wp, wq]
s3b  = Set.fromList [wpq, w0]
s3c  = Set.singleton wpq

-- Lara NarrowScope True
wNSa, wNSb, wNS :: Int
wNSa  = 0
wNSb  = 1
wNS = 2

uNS :: Set World
uNS = Set.fromList [0..2]

rNS :: Map World (Set World)
rNS = Map.fromSet r uNS where
  r 2 = Set.fromList [wNSa, wNSb]
  r _ = Set.empty

vNS :: Map World (Set Proposition)
vNS = Map.fromList [
    (0, Set.singleton 1),
    (1, Set.singleton 2),
    (2, Set.empty)
  ]

mNS :: KrM
mNS = KrM uNS rNS vNS

sNS :: Team
sNS  = Set.singleton wNS

-- Lara NarrowScope False
wNSF1, wNSF2 :: Int
wNSF1 = 2
wNSF2 = 3

uNSF :: Set World
uNSF = Set.fromList [0..3]

rNSF :: Map World (Set World)
rNSF = Map.fromSet r uNSF where
  r 2 = Set.singleton wNSa
  r 3 = Set.singleton wNSb
  r _ = Set.empty

vNSF :: Map World (Set Proposition)
vNSF = Map.fromList [
    (0, Set.singleton 1),
    (1, Set.singleton 2),
    (2, Set.empty),
    (3, Set.empty)
  ]

mNSF :: KrM
mNSF = KrM uNSF rNSF vNSF

sNSF :: Team
sNSF  = Set.fromList [wNSF1, wNSF2]

-- Lara TautologyBoxDEF
wBa, wBb, wBc, wBd, wBbc, wBe, wBcd :: Int
wBa = 0
wBb = 1
wBc = 2
wBd = 3
wBbc = 4
wBe = 5
wBcd = 6

uB :: Set World
uB = Set.fromList [0..6]

rB :: Map World (Set World)
rB = Map.fromSet r uB where
  r 0 = Set.singleton wBd
  r 1 = Set.fromList [wBe, wBd, wBc]
  r 2 = Set.singleton wBc
  r 4 = Set.singleton wBcd
  r _ = Set.empty

vB :: Map World (Set Proposition)
vB = Map.fromList [
    (0, Set.singleton 1),
    (1, Set.singleton 2),
    (2, Set.singleton 3),
    (3, Set.singleton 4),
    (4, Set.fromList [2, 3]),
    (5, Set.singleton 5),
    (6, Set.fromList [3, 4])
  ]


mB :: KrM
mB = KrM uB rB vB

sB :: Team
sB  = Set.fromList [wBa, wBb, wBc]


\end{code}

\begin{code}
-- Basic Modal Logic formulas
data MForm
  = MProp Proposition
  | MNeg MForm
  | MAnd MForm MForm
  | MOr  MForm MForm
  | MDia MForm
  deriving (Eq,Show)

instance Supportable KrM World MForm where
  (m,w) |= MProp n  = n `elem` val' m w
  (m,w) |= MNeg f   = not $ (m,w) |= f
  (m,w) |= MAnd f g = (m,w) |= f && (m,w) |= g
  (m,w) |= MOr f g  = (m,w) |= f || (m,w) |= g
  (m,w) |= MDia f   = any (\v -> (m,v) |= f) $ rel' m w


-- Modal formulas are a subset of BSML-formulas
toBSML :: MForm -> Form
toBSML (MProp n)  = Prop n
toBSML (MNeg f)   = Neg (toBSML f)
toBSML (MAnd f g) = And (toBSML f) (toBSML g)
toBSML (MOr f g)  = Or (toBSML f) (toBSML g)
toBSML (MDia f)   = Dia (toBSML f)

-- In Aloni2024, this is indicated by []+
enrich :: MForm -> Form
enrich (MProp n)  = Prop n `And` NE
enrich (MNeg f)   = Neg (enrich f) `And` NE
enrich (MDia f)   = Dia (enrich f) `And` NE
enrich (MAnd f g) = (enrich f `And` enrich g) `And` NE
enrich (MOr f g)  = (enrich f `Or`  enrich g) `And` NE
\end{code}
